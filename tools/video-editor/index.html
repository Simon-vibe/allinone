<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="video.meta.title">Browser Video Editor - Trim, Cut & Convert Locally</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŽ¬</text></svg>">
    <meta name="description"
        content="Edit videos directly in your browser without uploading. Trim, cut, and convert format (MP4/GIF) locally using FFmpeg WASM."
        data-i18n="video.meta.desc">
    <meta name="keywords"
        content="video editor, trim video online, ffmpeg wasm, convert video to gif, cut video browser"
        data-i18n="video.meta.keywords">

    <!-- Canonical -->
    <link rel="canonical" href="https://allinone.page/tools/video-editor/">

    <!-- Hreflang -->
    <link rel="alternate" hreflang="en" href="https://allinone.page/tools/video-editor/" />
    <link rel="alternate" hreflang="zh" href="https://allinone.page/tools/video-editor/?lang=zh" />
    <link rel="alternate" hreflang="x-default" href="https://allinone.page/tools/video-editor/" />

    <!-- Open Graph -->
    <meta property="og:url" content="https://allinone.page/tools/video-editor/">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Browser Video Editor">
    <meta property="og:description" content="Secure, local video editing and conversion using WebAssembly.">
    <meta property="og:image" content="https://allinone.page/assets/og-image.png">

    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Range Slider Styling */
        .range-slider {
            position: relative;
            height: 20px;
        }
    </style>
    <!-- COI for SharedArrayBuffer -->
    <script src="coi-serviceworker.js?v=2"></script>
</head>

<body class="bg-gray-50 text-gray-800 min-h-screen flex flex-col">

    <!-- Navbar -->
    <nav class="bg-white py-4 shadow-sm">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 flex justify-between items-center">
            <div class="flex items-center space-x-2">
                <i class="fa-solid fa-screwdriver-wrench text-blue-600 text-2xl"></i>
                <a href="../../index.html" class="text-xl font-bold text-gray-900">allinone.page</a>
            </div>
            <div class="hidden md:flex items-center space-x-8 text-sm font-medium text-gray-600">
                <a href="../../index.html" class="hover:text-blue-600 transition" data-i18n="nav.home">Home</a>
                <a href="../../index.html#all-tools" class="hover:text-blue-600 transition"
                    data-i18n="nav.categories">Categories</a>
                <a href="../../about.html" class="hover:text-blue-600 transition" data-i18n="nav.about">About</a>
                <div class="flex items-center space-x-2 border-l pl-6 border-gray-300">
                    <button onclick="changeLanguage('en')" id="lang-en"
                        class="hover:text-blue-800 transition">EN</button>
                    <span class="text-gray-300">/</span>
                    <button onclick="changeLanguage('zh')" id="lang-zh"
                        class="hover:text-blue-800 transition">ä¸­æ–‡</button>
                </div>
            </div>
        </div>
    </nav>

    <!-- Tool Header -->
    <div class="bg-blue-600 text-white py-12 mb-8">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 text-center">
            <h1 class="text-3xl font-bold mb-4" data-i18n="tool.video.title">Browser Video Editor</h1>
            <p class="text-blue-100 max-w-2xl mx-auto" data-i18n="tool.video.desc">Trim, cut, and convert videos locally
                using FFmpeg WASM. No upload required.</p>
        </div>
    </div>

    <!-- Main Content -->
    <main class="flex-grow max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 w-full">

        <!-- File Upload Area -->
        <div id="upload-area"
            class="border-2 border-dashed border-blue-200 rounded-xl p-12 text-center bg-blue-50 hover:bg-blue-100 transition cursor-pointer mb-8">
            <input type="file" id="file-input" class="hidden" accept="video/*">
            <i class="fa-solid fa-film text-5xl text-blue-400 mb-4"></i>
            <h3 class="text-xl font-bold text-gray-700 mb-2" data-i18n="video.drop.title">Drag & Drop Video Here</h3>
            <p class="text-gray-500" data-i18n="video.drop.desc">or click to upload (MP4, WEBM, MOV)</p>
        </div>

        <!-- Editor Area -->
        <div id="editor-area" class="hidden grid grid-cols-1 lg:grid-cols-3 gap-8">

            <!-- Left: Player & Controls -->
            <div class="lg:col-span-2 space-y-6">

                <!-- Video Player Container with Crop Overlay -->
                <div class="relative bg-black rounded-xl overflow-hidden shadow-lg group select-none"
                    id="video-container">
                    <video id="video-preview" controls class="w-full max-h-[500px] mx-auto block"></video>

                    <!-- Crop Overlay -->
                    <div id="crop-overlay" class="hidden absolute inset-0 pointer-events-none z-10 overflow-hidden">
                        <div id="crop-box"
                            class="absolute border-2 border-green-500 bg-green-500/20 pointer-events-auto cursor-move touch-none"
                            style="left: 25%; top: 25%; width: 50%; height: 50%;">

                            <!-- Handles -->
                            <div class="crop-handle nw absolute -top-1.5 -left-1.5 w-3 h-3 bg-green-500 border border-white rounded-full cursor-nw-resize"
                                data-pos="nw"></div>
                            <div class="crop-handle ne absolute -top-1.5 -right-1.5 w-3 h-3 bg-green-500 border border-white rounded-full cursor-ne-resize"
                                data-pos="ne"></div>
                            <div class="crop-handle sw absolute -bottom-1.5 -left-1.5 w-3 h-3 bg-green-500 border border-white rounded-full cursor-sw-resize"
                                data-pos="sw"></div>
                            <div class="crop-handle se absolute -bottom-1.5 -right-1.5 w-3 h-3 bg-green-500 border border-white rounded-full cursor-se-resize"
                                data-pos="se"></div>

                            <!-- Size Display -->
                            <div id="crop-size-display"
                                class="absolute -top-8 left-0 bg-black/80 text-white text-xs px-2 py-1 rounded whitespace-nowrap">
                                1280 x 720
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Crop Toggle -->
                <div class="flex items-center space-x-4 px-1">
                    <label class="flex items-center space-x-2 cursor-pointer select-none">
                        <input type="checkbox" id="enable-crop"
                            class="form-checkbox w-5 h-5 text-blue-600 rounded focus:ring-blue-500">
                        <span class="text-sm font-bold text-gray-700" data-i18n="video.crop.enable">Enable Crop</span>
                    </label>
                    <p class="text-xs text-gray-400" data-i18n="video.crop.desc">Drag to adjust area. Note: Cropping
                        requires re-encoding (slower).</p>
                </div>

                <!-- Trimming Controls -->
                <div class="bg-white rounded-xl shadow-sm border border-gray-100 p-6">
                    <h3 class="font-bold text-gray-900 mb-4" data-i18n="video.label.trim">Trim Video</h3>

                    <div class="flex space-x-4 mb-4">
                        <div class="flex-1">
                            <label class="text-xs text-gray-500 font-bold uppercase" data-i18n="video.label.start">Start
                                Time</label>
                            <input type="number" id="start-time" value="0" step="0.1"
                                class="w-full border border-gray-300 rounded p-2 text-sm mt-1">
                        </div>
                        <div class="flex-1">
                            <label class="text-xs text-gray-500 font-bold uppercase" data-i18n="video.label.end">End
                                Time</label>
                            <input type="number" id="end-time" value="0" step="0.1"
                                class="w-full border border-gray-300 rounded p-2 text-sm mt-1">
                        </div>
                    </div>

                    <p class="text-xs text-gray-400">
                        <i class="fa-solid fa-circle-info mr-1"></i>
                        <span data-i18n="video.tip.time">Enter start/end times in seconds. Play video to find correct
                            timestamps.</span>
                    </p>
                </div>

            </div>

            <!-- Right: Actions & Log -->
            <div class="lg:col-span-1 space-y-6">

                <!-- Conversion Options -->
                <div class="bg-white rounded-xl shadow-sm border border-gray-100 p-6">
                    <h3 class="font-bold text-gray-900 mb-4" data-i18n="video.label.opt">Output Options</h3>

                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-2"
                            data-i18n="video.label.format">Format</label>
                        <select id="format-select" class="w-full border border-gray-300 rounded-lg p-2 text-sm">
                            <option value="mp4">MP4 (H.264)</option>
                            <option value="gif">GIF (Animated)</option>
                            <option value="mp3">MP3 (Audio Only)</option>
                        </select>
                    </div>

                    <button id="btn-process"
                        class="w-full bg-blue-600 text-white py-3 rounded-lg font-bold hover:bg-blue-700 transition flex items-center justify-center shadow-md disabled:bg-gray-300 disabled:cursor-not-allowed">
                        <i class="fa-solid fa-gears mr-2"></i>
                        <span data-i18n="video.action.process">Process Video</span>
                    </button>

                    <div id="progress-container" class="hidden mt-4">
                        <div class="w-full bg-gray-200 rounded-full h-2.5">
                            <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
                        </div>
                        <p id="progress-text" class="text-xs text-center text-gray-500 mt-2">Initializing...</p>
                    </div>

                </div>

                <!-- Results -->
                <div id="result-area" class="hidden bg-white rounded-xl shadow-sm border border-gray-100 p-6">
                    <h3 class="font-bold text-gray-900 mb-4" data-i18n="video.label.result">Result</h3>
                    <div id="output-preview" class="mb-4 flex justify-center"></div>
                    <a id="btn-download" href="#"
                        class="w-full bg-green-600 text-white py-2 rounded-lg font-bold hover:bg-green-700 transition flex items-center justify-center text-sm shadow-sm">
                        <i class="fa-solid fa-download mr-2"></i>
                        <span data-i18n="common.download">Download</span>
                    </a>
                </div>

                <!-- Logs -->
                <div class="bg-gray-900 rounded-xl p-4 text-xs font-mono text-green-400 h-[200px] overflow-y-auto"
                    id="log-output">
                    <span class="text-gray-500">// System Ready</span><br>
                </div>

            </div>
        </div>

        <!-- FAQ -->
        <section class="max-w-4xl mx-auto mt-16 prose prose-blue text-gray-600 mb-12">
            <h2 class="text-2xl font-bold text-gray-900 mb-4" data-i18n="video.faq.title">Browser Video Editor FAQ</h2>
            <p class="mb-4" data-i18n="video.faq.desc">Editing video traditionally requires powerful local software or
                uploading large files to a server. We use WebAssembly to solve this.</p>

            <h3 class="text-xl font-bold text-gray-900 mb-2" data-i18n="common.features">Features</h3>
            <ul class="list-disc pl-5 space-y-2 mb-6">
                <li data-i18n="video.feat.1"><strong>Local Processing:</strong> Your video never leaves your browser.
                    Zero privacy risk.</li>
                <li data-i18n="video.feat.2"><strong>FFmpeg WASM:</strong> Powered by the industry-standard video
                    processing engine, ported to the web.</li>
                <li data-i18n="video.feat.3"><strong>Cross-Platform:</strong> Works on Windows, Mac, and Linux browsers
                    (Chrome/Edge/Firefox recommended).</li>
            </ul>
        </section>

    </main>

    <!-- Footer -->
    <footer class="bg-white border-t border-gray-100 mt-12 py-8">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 text-center text-sm text-gray-400">
            <span data-i18n="footer.rights">&copy; 2026 allinone.page. All rights reserved.</span>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.7/dist/umd/ffmpeg.js"></script>
    <script src="https://unpkg.com/@ffmpeg/util@0.12.1/dist/umd/index.js"></script>
    <script src="../../js/i18n.js?v=2"></script>

    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const { FFmpeg } = FFmpegWASM;
            const { fetchFile } = FFmpegUtil;

            const uploadArea = document.getElementById('upload-area');
            const fileInput = document.getElementById('file-input');
            const editorArea = document.getElementById('editor-area');
            const videoPreview = document.getElementById('video-preview');
            const startTimeInput = document.getElementById('start-time');
            const endTimeInput = document.getElementById('end-time');
            const btnProcess = document.getElementById('btn-process');
            const formatSelect = document.getElementById('format-select');
            const progressContainer = document.getElementById('progress-container');
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            const resultArea = document.getElementById('result-area');
            const outputPreview = document.getElementById('output-preview');
            const btnDownload = document.getElementById('btn-download');
            const logOutput = document.getElementById('log-output');

            let ffmpeg = null;
            let inputFile = null;

            // Logger
            const log = (msg) => {
                logOutput.innerHTML += `> ${msg}<br>`;
                logOutput.scrollTop = logOutput.scrollHeight;
            };

            // Initialize FFmpeg
            const loadFFmpeg = async () => {
                log(`Loading FFmpeg engine... (Isolated: ${window.crossOriginIsolated})`);
                if (!window.crossOriginIsolated) {
                    log("WARNING: Page is not cross-origin isolated. SharedArrayBuffer may fail.");
                }
                ffmpeg = new FFmpeg();

                ffmpeg.on('log', ({ message }) => {
                    // Only log relevant info to avoid spamming
                    if (message.includes('frame=') || message.includes('size=')) {
                        // Optional: update UI detail
                    } else {
                        // log(message); 
                    }
                });

                ffmpeg.on('progress', ({ progress }) => {
                    const percent = Math.round(progress * 100);
                    progressBar.style.width = `${percent}%`;
                    progressText.textContent = `Processing: ${percent}%`;
                });

                try {
                    // Load binaries from CDN
                    await ffmpeg.load({
                        coreURL: 'ffmpeg-core.js',
                        wasmURL: 'ffmpeg-core.wasm',
                    });
                    log("Engine loaded successfully.");
                    btnProcess.disabled = false;
                } catch (e) {
                    log("Error loading engine: " + e.message);
                    console.error(e);
                    alert("Failed to load video engine. Your browser might not support SharedArrayBuffer. Please use latest Chrome/Edge on Desktop.");
                }
            };

            // Only load when user uploads (save bandwidth) or immediately?
            // Let's load immediately to be ready
            loadFFmpeg();

            // File Handling
            uploadArea.addEventListener('click', () => fileInput.click());

            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) handleFile(e.target.files[0]);
            });

            function handleFile(file) {
                inputFile = file;
                const url = URL.createObjectURL(file);
                videoPreview.src = url;

                // Reset UI
                editorArea.classList.remove('hidden');
                uploadArea.classList.add('hidden');
                resultArea.classList.add('hidden');

                // Reset crop
                enableCropCheckbox.checked = false;
                cropOverlay.classList.add('hidden');

                // Get duration
                videoPreview.onloadedmetadata = () => {
                    endTimeInput.value = videoPreview.duration.toFixed(1);
                    log(`Loaded video: ${file.name} (${videoPreview.duration.toFixed(1)}s)`);
                };
            }

            // --- Crop Logic ---
            const enableCropCheckbox = document.getElementById('enable-crop');
            const cropOverlay = document.getElementById('crop-overlay');
            const cropBox = document.getElementById('crop-box');
            const videoContainer = document.getElementById('video-container');
            const cropSizeDisplay = document.getElementById('crop-size-display');

            enableCropCheckbox.addEventListener('change', (e) => {
                if (e.target.checked) {
                    cropOverlay.classList.remove('hidden');
                    updateCropDisplay(); // Initial update
                } else {
                    cropOverlay.classList.add('hidden');
                }
            });

            // Crop Box Drag & Resize
            let isDragging = false;
            let isResizing = false;
            let currentHandle = null;
            let startX, startY;
            let startLeft, startTop, startWidth, startHeight;

            const handles = document.querySelectorAll('.crop-handle');
            handles.forEach(handle => {
                handle.addEventListener('mousedown', (e) => {
                    e.stopPropagation(); // Prevent drag
                    isResizing = true;
                    currentHandle = handle.dataset.pos;
                    startX = e.clientX;
                    startY = e.clientY;
                    startLeft = cropBox.offsetLeft;
                    startTop = cropBox.offsetTop;
                    startWidth = cropBox.offsetWidth;
                    startHeight = cropBox.offsetHeight;
                    document.addEventListener('mousemove', onResize);
                    document.addEventListener('mouseup', stopResize);
                });
            });

            cropBox.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('crop-handle')) return;
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startLeft = cropBox.offsetLeft;
                startTop = cropBox.offsetTop;
                document.addEventListener('mousemove', onDrag);
                document.addEventListener('mouseup', stopDrag);
            });

            function onDrag(e) {
                if (!isDragging) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;

                let newLeft = startLeft + dx;
                let newTop = startTop + dy;

                // Constraints
                const maxLeft = videoContainer.offsetWidth - cropBox.offsetWidth;
                const maxTop = videoContainer.offsetHeight - cropBox.offsetHeight;

                newLeft = Math.max(0, Math.min(newLeft, maxLeft));
                newTop = Math.max(0, Math.min(newTop, maxTop));

                cropBox.style.left = px(newLeft);
                cropBox.style.top = px(newTop);
                updateCropDisplay();
            }

            function stopDrag() {
                isDragging = false;
                document.removeEventListener('mousemove', onDrag);
                document.removeEventListener('mouseup', stopDrag);
            }

            function onResize(e) {
                if (!isResizing) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;

                let newWidth = startWidth;
                let newHeight = startHeight;
                let newLeft = startLeft;
                let newTop = startTop;

                if (currentHandle.includes('e')) newWidth = Math.max(20, startWidth + dx);
                if (currentHandle.includes('s')) newHeight = Math.max(20, startHeight + dy);
                if (currentHandle.includes('w')) {
                    newWidth = Math.max(20, startWidth - dx);
                    newLeft = startLeft + (startWidth - newWidth);
                }
                if (currentHandle.includes('n')) {
                    newHeight = Math.max(20, startHeight - dy);
                    newTop = startTop + (startHeight - newHeight);
                }

                // Boundary checks (simplified)
                if (newLeft < 0) { newWidth += newLeft; newLeft = 0; }
                if (newTop < 0) { newHeight += newTop; newTop = 0; }
                if (newLeft + newWidth > videoContainer.offsetWidth) newWidth = videoContainer.offsetWidth - newLeft;
                if (newTop + newHeight > videoContainer.offsetHeight) newHeight = videoContainer.offsetHeight - newTop;

                cropBox.style.width = px(newWidth);
                cropBox.style.height = px(newHeight);
                cropBox.style.left = px(newLeft);
                cropBox.style.top = px(newTop);
                updateCropDisplay();
            }

            function stopResize() {
                isResizing = false;
                document.removeEventListener('mousemove', onResize);
                document.removeEventListener('mouseup', stopResize);
            }

            function px(v) { return v + 'px'; }

            function updateCropDisplay() {
                const rect = videoPreview.getBoundingClientRect();
                if (rect.width === 0) return;

                const scaleX = videoPreview.videoWidth / rect.width;
                const scaleY = videoPreview.videoHeight / rect.height;

                const w = Math.round(cropBox.offsetWidth * scaleX);
                const h = Math.round(cropBox.offsetHeight * scaleY);

                cropSizeDisplay.textContent = `${w} x ${h}`;
            }

            // Sync video resize
            new ResizeObserver(updateCropDisplay).observe(videoPreview);


            // Processing Logic
            btnProcess.addEventListener('click', async () => {
                if (!ffmpeg || !inputFile) return;

                const start = startTimeInput.value;
                const duration = (endTimeInput.value - start).toFixed(2);
                const format = formatSelect.value;
                const outputName = `output.${format}`;

                if (duration <= 0) {
                    alert("End time must be greater than start time.");
                    return;
                }

                btnProcess.disabled = true;
                progressContainer.classList.remove('hidden');
                progressBar.style.width = '0%';

                log("Starting operation...");

                try {
                    // 1. Write file
                    await ffmpeg.writeFile('input', await fetchFile(inputFile));

                    // 2. Build command
                    let args = [];
                    // -ss before -i is faster (input seeking)
                    args.push('-ss', start.toString());
                    args.push('-i', 'input');
                    args.push('-t', duration.toString()); // Duration to keep

                    if (format === 'mp4') {
                        // Fast preset
                        args.push('-c:v', 'libx264', '-preset', 'ultrafast');
                    } else if (format === 'gif') {
                        // Optimize GIF palette
                        // Note: If cropping, we need to apply crop filter BEFORE split
                        // But to simplify, we build a filter chain
                    } else if (format === 'mp3') {
                        // Extract audio
                        args.push('-vn', '-acodec', 'libmp3lame');
                    }

                    // --- Crop logic ---
                    if (enableCropCheckbox.checked && format !== 'mp3') { // MP3 has no video
                        const rect = videoPreview.getBoundingClientRect();
                        const scaleX = videoPreview.videoWidth / rect.width;
                        const scaleY = videoPreview.videoHeight / rect.height;

                        // Calculate relative to video container overlay
                        // The cropBox is within videoContainer, which matches videoPreview size (if object-fit contain/cover handled right)
                        // Actually videoContainer wraps videoPreview. videoPreview might be smaller if aspect ratio differs?
                        // The CSS says video-preview is w-full. 
                        // To be precise, we need relative pos of cropbox to crop-overlay (which is inset-0 of container)
                        // and container matches video size? NO.
                        // Wait, video might have black bars if object-fit isn't fill.
                        // BUT standard <video> tag without object-fit matches the video aspect ratio if width is set?
                        // Video css is `w-full max-h-[500px]`.
                        // The container is `relative bg-black`.
                        // If video is letterboxed, the crop box might be over black bars.
                        // We must assume the user crops the valid area.

                        // We calculated scale based on displayed video rect.
                        // CropBox offsets are relative to container.
                        // We need offset of video within container? 
                        // The video is `block mx-auto`. It's likely centered or taking full width.

                        // Let's rely on getBoundingClientRect comparisons for robustness
                        const boxRect = cropBox.getBoundingClientRect();
                        const vidRect = videoPreview.getBoundingClientRect();

                        const cropX = Math.round((boxRect.left - vidRect.left) * scaleX);
                        const cropY = Math.round((boxRect.top - vidRect.top) * scaleY);
                        const cropW = Math.round(boxRect.width * scaleX);
                        const cropH = Math.round(boxRect.height * scaleY);

                        // Ensure valid crop
                        const finalX = Math.max(0, cropX);
                        const finalY = Math.max(0, cropY);
                        // Prevent out of bounds
                        const finalW = Math.min(cropW, videoPreview.videoWidth - finalX);
                        const finalH = Math.min(cropH, videoPreview.videoHeight - finalY);

                        const cropFilter = `crop=${finalW}:${finalH}:${finalX}:${finalY}`;

                        if (format === 'gif') {
                            // Prepend crop to existing filter
                            // Current GIF filter: fps=10,scale=320:-1:flags=lanczos,split...
                            // We should crop FIRST, then scale.
                            // Complex filter syntax: [0:v]crop=...[cropped];[cropped]fps=10...
                            // But easy way: just comma separate if linear?
                            // Yes: crop=...,fps=10...
                            const gifFilter = `fps=10,scale=320:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse`;
                            args.push('-vf', `${cropFilter},${gifFilter}`);
                        } else {
                            // MP4
                            args.push('-vf', cropFilter);
                        }
                    } else if (format === 'gif') {
                        // Default GIF filter if no crop
                        args.push('-vf', 'fps=10,scale=320:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse');
                    }

                    args.push(outputName);

                    log(`Running command: ffmpeg ${args.join(' ')}`);

                    // 3. Exec
                    await ffmpeg.exec(args);

                    log("Processing finished.");

                    // 4. Read Result
                    const data = await ffmpeg.readFile(outputName);

                    // 5. Create URL
                    const blob = new Blob([data.buffer], { type: format === 'mp4' ? 'video/mp4' : (format === 'gif' ? 'image/gif' : 'audio/mpeg') });
                    const url = URL.createObjectURL(blob);

                    // 6. Show Result
                    resultArea.classList.remove('hidden');
                    btnDownload.href = url;
                    btnDownload.download = outputName;

                    if (format === 'gif') {
                        outputPreview.innerHTML = `<img src="${url}" class="max-w-full rounded shadow">`;
                    } else if (format === 'mp4') {
                        outputPreview.innerHTML = `<video src="${url}" controls class="max-w-full rounded shadow"></video>`;
                    } else {
                        outputPreview.innerHTML = `<audio src="${url}" controls class="w-full"></audio>`;
                    }

                } catch (e) {
                    log("Error: " + e.message);
                    console.error(e);
                    alert("Processing failed. Check logs.");
                } finally {
                    btnProcess.disabled = false;
                    progressContainer.classList.add('hidden');
                }
            });
        });
    </script>
</body>

</html>